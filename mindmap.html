<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<style>
button, input, select, textarea {
  font-size: 1rem;
}
/* sizing, layout */
* {
  box-sizing: border-box;
}
html {
  height: 100vh;
  margin: 0;
}
body {
  margin: 0;
}
.w-fit {
  width:fit-content;
}
.w-full {
  width: 100%;
}
.h-full {
  height: 100%;
}
.wh-full {
  width: 100%;
  height: 100%;
}
/* view */
.hidden {
  visibility: hidden;
}
.none {
  display: none;
}
.bg-trans {
  background-color: transparent;
}
.bg-white {
  background-color: #fff;
}
.rel {
  position: relative;
}
.abs {
  position: absolute;
}
.m-0 {
  margin: 0;
}
.p-0 {
  padding: 0;
}
.pr-2 {
  padding-right: 0.5rem;
}

/* flex */
.flex {
  display: flex;
  align-items: flex-start;
}
.fcol {
  flex-direction: column;
}
.grow {
  flex-grow: 1;
}
.text-center {
  text-align: center;
}
.jus-bw {
  justify-content: space-between;
}

/* application */
:root {
  --curtype: pointer;
}
.mind {
  padding: 0.2rem 0.5rem; /* up-down | left-right */
  color: #222;
  border: solid 1.5px #222;
  border-radius: 0.8rem;
  width: fit-content;
  min-width: 10rem;
  max-width: 80%;
  user-select: none;
  position: absolute;
  background-color: #fff;
  &.bg-0 { background-color: #fff; }
  &.bg-1 { background-color: #faa; }
  &.bg-2 { background-color: #aaf; }
  &.bg-3 { background-color: #afa; }
  &.bg-4 { background-color: #ffa; }
  &.bg-5 { background-color: #faf; }
  &.bg-6 { background-color: #aff; }
  &.bg-7 { background-color: #aaa; }
  &.selected {
    border-color: #f22;
  }
  &:hover {
    cursor: var(--curtype, pointer);
  }
  & div {
    text-align: center;
  }
}

/* menu button */
.menu-btn {
  width: 8rem;
  margin: 0;
  padding: 0.25rem;
  font-weight: bold;
  text-align: center;
  user-select: none;
  border-style: solid;
  border-color:blue;
  border-radius: 0;
  border-width: 1px;
  border-collapse: collapse;
  background-color: white;
  color: blue;
  &:hover {
    background-color: blue;
    color: white;
    cursor: pointer;
  }
  &:first-child {
    border-top-left-radius: 0.8rem;
    border-top-right-radius: 0.8rem;
  }
  &:last-child {
    border-bottom-left-radius: 0.8rem;
    border-bottom-right-radius: 0.8rem;
  }
}

.rel-line {
  margin: 0;
  padding: 0;
  border: 0;
  height: 4px;
  background-color: black;
  opacity: 20%;
  border-radius: 0.2rem;
  transform-origin: 0% 0%;
}

.truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.root-node {
  top: 5rem;
  left: 10rem;
}

#lock-screen {
  background-color: black;
  opacity: 40%;
}

.line-a { /* \ */
  background: linear-gradient(7deg,#fff 0%,#fff 49%,#444 49%,#444 51%,#fff 51%,#fff 100%);
}
.line-b { /* / */
}
</style>

</head>
<body class="w-full h-full flex">
<!-- [[ relation layer ]] -->
<div id="background" class="abs wh-full">
  <!-- lines -->
  <span id="lines"></span>
  <!-- original -->
  <div id="line_base" name="liner" class="abs hidden rel-line"></div>
</div>
<!-- [[ mind layer ]] -->
<div id="foreground" class="abs wh-full" style="background-color: transparent">
  <!-- node -->
  <span id="child_minds"></span>
  <div class="flex mind root-node" id="m0" data-parent="">
    <div name="data" class="grow w-fit truncate">Mind Map</div>
  </div>
  <!-- sub menu -->
  <span class="abs hidden" id="submenu">
    <div class="flex fcol w-fit r-col">
      <div class="menu-btn" id="btn_del">Del</div>
      <div class="menu-btn" id="btn_col">Color</div>
      <div class="menu-btn" id="btn_new">New</div>
      <div class="menu-btn" id="btn_edt">Edit</div>
    </div>
  </span>
</div>
<!-- [[ lock Layer ]] -->
<div id="lock-screen" class="abs wh-full none">
<!-- [[ input form layer ]] -->
<form action="#" id="input_form" class="abs hidden">
  <div id="input_form" class="flex w-fit">
    <input type="text" maxlength=80 class="truncate">
  </div>
</form>

<script>
(function(){
  // DOM
  const root = document.querySelector(':root');
  const menu = document.getElementById('submenu');
  const background = document.getElementById('background');
  const foreground = document.getElementById('foreground');
  /**
   * マウスまわりの処理
   */
  const clickPos = {x: null, y:null};
  document.addEventListener('mousedown', function(ev) {
    clickPos.x = ev.pageX;
    clickPos.y = ev.pageY;
    const mind = ev.target.closest('.mind');
    // menu
    if (mind != null) {
      mind.classList.add('dragging');
      mind.setAttribute('px', ev.pageX - mind.offsetLeft);
      mind.setAttribute('py', ev.pageY - mind.offsetTop);
      document.addEventListener("mouseup", mouseUp);
      document.addEventListener("mousemove", mouseMove);

      const allMind = foreground.querySelectorAll('.mind');
      for (const m of allMind) {
        m.classList.remove('selected');
      }
      mind.classList.add('selected');
    }
  });
  function mouseMove(ev) {
    const target = foreground.querySelector('.dragging');
    if (target != null) {
      root.style.setProperty('--curtype', 'grabbing');
      const x = (target.getAttribute('px') ?? 0) - 0;
      const y = (target.getAttribute('py') ?? 0) - 0;
      target.style.left = `${ev.pageX - x}px`;
      target.style.top = `${ev.pageY - y}px`;
      lineReset(target); // リアルタイムに関係線を引き直す（重くないはず？ V8パワーを見せてくれ！）
      document.addEventListener("mouseleave", mouseUp);
      menu.classList.add('hidden');
      ev.preventDefault();
    }
  }
  function mouseUp(ev) {
    root.style.setProperty('--curtype', 'pointer');
    const target = foreground.querySelector('.dragging');
    if (target != null) {
      // lineReset(target);
      document.removeEventListener("mouseMove", mouseUp);
      document.removeEventListener("mouseleave", mouseUp);
      document.removeEventListener("mouseUp", mouseUp);
      target.classList.remove('dragging');
    }
    const delta = ((ev.pageX - clickPos.x) ** 2) + ((ev.pageY - clickPos.y) ** 2);
    if (delta < 4) {
      clickAction(ev);
    }
  }
  function clickAction(ev) {
    menuAction(ev);
  }
  /**
   * メニュー処理
   */
  function menuAction(ev) {
    const elm = ev.target;
    const mind = elm.closest('.mind');
    if (menu.classList.contains('hidden')) {
      // メニューが非表示でマインドクリック時はメニュー表示
      if (mind != null) {
        const moh = menu.offsetHeight;
        if (moh > mind.offsetTop) {
          menu.style.top = `${mind.offsetTop + mind.offsetHeight + 1}px`;
        } else {
          menu.style.top = `${mind.offsetTop - moh - 1}px`;
        }
        menu.style.left = `${mind.offsetLeft}px`;
        menu.classList.remove('hidden');
      }
    } else {
      // メニュー表示中はメニューをクリックされたのかそれ以外かで処理を分ける
      if (elm.classList.contains('menu-btn')) {
        const mind = foreground.querySelector('.selected');
        switch (elm.textContent) {
          case 'Del':
            break;
          case 'Color':
            changeColor(mind);
            break;
          case 'New':
            newMind(mind);
            mind.classList.remove('selected');
            menu.classList.add('hidden');
            break;
          case 'Edit':
            break;
        }
      } else {
        menu.classList.add('hidden');
        // 別のマインドをクリックしている場合は、そこにメニュー表示
        if (mind != null) {
          setTimeout(function() {
            menuAction(ev);
          },10);
        }
      }
    }
  }
  /**
   * マインドの色を変える
   */
  function changeColor(mind) {
    let colIdx = 0;
    for (let i = 0; i < 8; i++) {
      if (mind.classList.contains(`bg-${i}`)) {
        mind.classList.remove(`bg-${i}`);
        colIdx = i;
        break;
      }
    }
    mind.classList.add(`bg-${(colIdx + 1) % 8}`);
  }
  /**
   * 新しいマインドを生み出す
   */
  function newMind(mind) {
    const nMind = mind.cloneNode(true);
    nMind.setAttribute('id', `m${Date.now()}`);
    nMind.setAttribute('data-parent', mind.getAttribute('id') ?? '');
    nMind.style.top = `${Math.floor(menu.offsetTop + (menu.offsetHeight / 2))}px`;
    nMind.querySelector('[name="data"]').textContent = 'new mind.';
    foreground.querySelector('#child_minds').appendChild(nMind);
    liner(mind, nMind);
  }

  /**
   * 線を引く
   */
  function liner(domA, domB) {
    const pos = getRelationPoint(domA, domB);
    const newLine = document.getElementById('line_base').cloneNode();
    newLine.setAttribute('id', `${pos.a.id ?? ''}-${pos.b.id ?? ''}`);
    reLine(newLine, pos);
    newLine.classList.remove('hidden');
    background.querySelector('#lines').appendChild(newLine);
  }
  function reLine(line, pos) {
    line.style.width = `${pos.len}px`;
    line.style.left = `${pos.a.x}px`;
    line.style.top = `${pos.a.y}px`;
    line.style.transform = `rotate(${pos.deg}deg)`;
  }
  function lineReset(mind) {
    const mindId = mind.getAttribute('id');
    background.querySelectorAll(`[id$="-${mindId}"]`).forEach(function(line) {
      const fromId = line.getAttribute('id').split('-')[0];
      reLine(line, getRelationPoint(foreground.querySelector(`[id=${fromId}]`), mind));
    });
    background.querySelectorAll(`[id^="${mindId}-"]`).forEach(function(line) {
      const toId = line.getAttribute('id').split('-')[1];
      reLine(line, getRelationPoint(mind, foreground.querySelector(`[id=${toId}]`)));
    });
  }
  /**
   * ２つのDOMの中心点と、引数１のDOMから引数２のDOMへの角度と距離を取得する
   */
  function getRelationPoint(domA, domB) {
    const a = {
      x: domA.offsetLeft + (domA.offsetWidth / 2),
      y: domA.offsetTop + (domA.offsetHeight / 2),
      id: domA.getAttribute('id'),
    };
    const b = {
      x: domB.offsetLeft + (domB.offsetWidth / 2),
      y: domB.offsetTop + (domB.offsetHeight / 2),
      id: domB.getAttribute('id'),
    };
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dd = Math.sqrt((dx ** 2) + (dy ** 2));
    let deg = Math.acos(dx / dd) * 180 / Math.PI;
    if (dy < 0) {
      deg = 360 - deg;
    }
    return {a: a, b: b, deg: deg, len:dd};
  }

})();
</script>
</body>
</html>